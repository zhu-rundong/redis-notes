# 7.3 连锁更新

例如，在一个压缩列表中， 有多个连续的、长度介于 **250** 字节到 **253** 字节之间的节点 e1 至 eN ，如下表所示：

|zlbytes|zltail|zllen|e1|e2|e3|......|en|zlend|
| ---------| --------| -------| ----| ----| ----| --------| ----| -------|

这时， 我们将一个长度大于等于 **254** 字节的新节点 **new** 设置为压缩列表的表头节点， 那么 new 将成为 **e1** 的前置节点， 如下表所示：

|zlbytes|zltail|zllen|new|e1|e2|e3|......|en|zlend|
| ---------| --------| -------| -----| ----| ----| ----| --------| ----| -------|

由于 **e1** 的 `previous_entry_length`属性长度 **1** 字节， 它没办法保存新节点 **new** 的长度， 所以需要对压缩列表执行空间重分配操作， 并将 **e1** 节点的 `previous_entry_length`属性从原来的 1 字节长扩展为 5 字节长。

但是，**e1** 原本的长度介于 **250** 字节至 **253** 字节之间， 在为`previous_entry_length`属性新增四个字节的空间之后， **e1** 的长度就变成了介于 **254** 字节至 **257**  字节之间。此时，**e2** 又无法保存 **e1** 的长度，需要扩展 **e2**......，依次类推，程序需要不断地对压缩列表执行空间重分配操作， 直到 **en** 为止。

Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）。

除了添加新节点可能会引发连锁更新之外， 删除节点也可能会引发连锁更新。

|zlbytes|zltail|zllen|big|small|e1|e2|e3|......|en|zlend|
| ---------| --------| -------| -----| -------| ----| ----| ----| --------| ----| -------|

上表中， e1 至 eN 都是长度介于 **250** 字节到 **253** 字节之间的节点，**big** 节点长度大于 **254** 字节，**small** 节点长度小于 **254** 字节，当删除 **small** 节点，依然会引起 **e1** 到 **en** 的连锁更新。

连锁更新在最坏情况下需要对压缩列表执行 **N** 次空间重分配操作， 而每次空间重分配的最坏复杂度为 **O(N)** ， 所以连锁更新的最坏复杂度为 O(N^2^)。

尽管连锁更新的复杂度较高， 但它真正造成性能问题的几率是很低的：

* 首先， 压缩列表里要恰好有多个连续的、长度介于 **250** 字节到 **253** 字节之间的节点， 连锁更新才有可能被引发， 在实际中， 这种情况并不多见
* 其次， 即使出现连锁更新， 但只要被更新的节点数量不多， 就不会对性能造成任何影响。
